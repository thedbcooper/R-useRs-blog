---
title: "R Packages Deep Dive"
description: "R packages can get overwhelming. This post discusses foundational concepts of packages, how to install and load, and describes some best practices for handling multiple packages in your R code."
author: "Daniel B. Cooper ([daniel.cooper@ky.gov](mailto:daniel.cooper@ky.gov))"
date: "3/6/2025"
date-modified: last-modified
categories:
  - code
image: lifecycle.svg
---

![](images/logo-dplyr.png)

## What is a package?

*Packages* are collections of R functions, data, and compiled code in a well-defined format. The directory where packages are stored is called the *library*.

## What is "Base R?"

Base R can refer to a collection of packages that are installed by default with R and live in the "system library." They are "built-in." These basic packages allow R to work. We can use the `sessionInfo()` function to find which packages are being used by our current R session.

```{r}
sessionInfo()
```

When a package is "attached," functions that belong to that package are available for use by the user. We can also see package versions next to their name.

::: callout-tip
### Tip: Visual Cues

I will use visual cues (and recommend you do as well) to distinguish between normal text, packages and function names, etc. When you see a function name, it will be followed by "()". E.g. `sessionInfo()`. When you see a package name, it will be surrounded by curly brackets "{}". E.g. The {tidyr} package.
:::

### Why do we want/need more functionality beyond "Base R?"

Package development is community driven, and many packages have overlapping functionality. If you can think of a need, there's probably a package for it. There are clear "winners" in terms of number of downloads and active users for a package. Entirely new "dialects" of R programming have been borne out of community package development. The "[tidyverse](https://www.tidyverse.org/)", one such dialect, is a collection of packages with consistent principles that unify the packages. You can read more here: ["tidy tools manifesto."](The%20tidy%20tools%20manifesto%20•%20tidyverse)

Choice of package or function depend on what functionality is needed, what you value, and your aversion to risk. By risk, I mean the potential for functions to change or break when either your R version changes or the package version changes.

You will see me mostly using tidyverse packages because I value their human readability, consistent structure, and stability of included functions. Perhaps you're still concerned with sustainability and "dependency-bloat," so you stick with base R. Maybe you need functions that perform better, so you use the [{data.table}](Extension%20of%20%60data.frame%60%20•%20data.table) package, another R "dialect." Maybe you just prefer to use whichever functions require the least amount of code. There are other reasons you will come across that lead you to choose when and where to use a specific function.

::: callout-tip
### How can I tell if a package is popular or stable?

Do some research! When was the last update? Check out the version history. Find the source code on GitHub; look at how many stars/follows it has. Look at the dates of forum and blog posts that use the function/package in question. Your knowledge of which packages are most popular will grow with experience.
:::

## How to install an R package

Use the `install.packages()` function to install new packages. This will attempt to download and install a package from a "package repository." By default, R will use the ["CRAN"](The%20Comprehensive%20R%20Archive%20Network) repository (Comprehensive R Archive Network). There are other repos, like the public [Posit Package Manager](Home%20%7C%20Package%20Manager) which have a wider range of package versions built for different versions of R. To manage packages, it's easiest to use the RStudio GUI, but see `?update.packages()` for programmatic options.

```{r}
install.packages("tidyr", repos = "https://packagemanager.posit.co/cran/latest")
install.packages("dplyr", repos = "https://packagemanager.posit.co/cran/latest")
install.packages("conflicted", repos = "https://packagemanager.posit.co/cran/latest")

# not run:
# install.packages("tidyr", repos = "http://cran.us.r-project.org")
# ?update.packages()
```

::: callout-tip
#### You only need to install one time

Typically, you would not have `install.packages()` appear in your code. I use it here for demonstration purposes. Usually, when I want to install a package, I type the function into the console. Any R session you open will have access to your package library. The exception is if you are using an environment manager like {renv}.
:::

### Package Dependencies

Some packages have dependencies "under the hood." In other words, some packages rely on the functions/source code of other packages to work. R is smart enough to install dependencies by default, which means there will be package names you may *not* recognize in your library.

::: callout-caution
#### Caution

When you update a package, R may not successfully install the correct version of a dependency if you already had a previous version installed. This leads to several troubleshooting steps of updating packages. I recommend to avoid updating unless you have a good reason to do so. At a later time, we will discuss {renv}, an R environment manager.
:::

### Loading/Attaching a package

Packages are attached using the `library()` or `require()` functions. You will most often see `library()`. R will look to default library paths, so you will usually ***not*** see the library specified when using `library()`. You can view your library file paths available to your R session using the `.libPaths()` function.

```{r}
.libPaths()
```

```{r}
library(tidyr)
```

```{r}
sessionInfo()
```

::: callout-important
### Important: Attach packages with intentionality.

When you load a package using `library()`, you attach all functions and data associated with that package.

Only install and load a package if you know what functions you want to use. I recommend keeping a note specifying why you're attaching an entire package and which functions are most used.

Generally, we want our programming projects to be sustainable and reproducible. Attaching too many packages leads to ambiguity in your code and may lead to unexpected behavior, so don't do it!
:::

To disambiguate your code, you can use functions from a particular package *without* attaching the full package. To do this, use the double colon operator `::`

```{r}
# not run:
# tidyr::pivot_longer()
```

In this example, I'm accessing the function called `pivot_longer()` from the {tidyr} package. Notably, this did *not* require attaching the {tidyr} package using `library()`, BUT the package would still need to be installed first using `install.packages()`. While this is less clean (and longer!) than simply attaching the full package, I believe beginner R programmers greatly benefit from disambiguating their code using `::`.

### Where does it go in my script?

Generally, I like to load all packages at the beginning of my R script. I will have a code chunk or section dedicated to "setup," which might include several calls to `library()` and maybe loading in some data.

## Unexpected behavior

Did you attach too many packages? Is a function not working like you expected? Did R give you a warning that a function is deprecated or has been superseded?

### Masking

There exists ***NO*** rule that developers of packages must use different names or follow certain conventions or principles. This means that two separate packages may both attach a function when loaded that has the same name. Let's see what happens when the entire tidyverse is attached:

```{r}
library(tidyverse)
```

Note that most packages aren't so kind as to print out messages such as these.

We can see that the `dplyr::filter()` function masked the `stats::filter()` function. Same for `lag()`.

::: callout-important
### Important

The order in which you attach a package determines which version of a function will be used when you call that function in your code. With each new package attached, all previously attached functions with the same name will be "masked." This is what disambiguating your code using `::` helps with.
:::

The {conflicted} package helps you identify masking and ***forces*** the user to decide which function to prioritize.

```{r}
detach("package:tidyverse", unload = TRUE)

library(conflicted)
library(dplyr)

# not run:
# filter(starwars, species == "Human")
```

If the above `filter()` was run, it would result in an **Error**, and prevent me from rendering this document. The error would read:

```         
Error:
! [conflicted] filter found in 2 packages.
Either pick the one you want with `::`:
• dplyr::filter
• stats::filter
Or declare a preference with `conflicts_prefer()`:
• conflicts_prefer(dplyr::filter)
• conflicts_prefer(stats::filter)
Backtrace:
 1. conflicted (local) `<fn>`()
```

Notice how disambiguating with `dplyr::filter()` runs fine:

```{r}
dplyr::filter(starwars, species == "Human")
```

To fix the problem, let's use the `conflicts_prefer()` function from the {conflicted} package to specify which version of `filter()` we actually want to use.

```{r}
conflicted::conflicts_prefer(dplyr::filter)

```

Now, we can use our preferred `filter()` without the call to `dplyr::`

```{r}
filter(starwars, species == "Human")

```

::: callout-tip
### Built in data sets

Notice how I simply use the object called `starwars`? That's an example of a built in data imported by {dplyr} for demonstration purposes. It contains information on Star Wars characters. It's attached when {dplyr} is loaded.
:::

### Lifecycle

![](lifecycle.svg){width="500"}

Packages change over time. Some very prominent packages, like tidyr, supersede old packages while retaining some of the older functions. E.g. `gather()` versus `pivot_longer()`. View the help pages!

```{r}
# not run:
# ?tidyr::gather()
# ?tidyr::pivot_longer()

# create new data "starwars_select" from "starwars" and select specified columns.
starwars_select <- starwars |>
  dplyr::select(name, hair_color, skin_color, eye_color)

# from "starwars_select", use gather() to make data longer format, then sort by name
starwars_select |>
  tidyr::gather(key = "attribute", value = "value", hair_color, skin_color, eye_color, na.rm = TRUE) |>
  dplyr::arrange(name)

```

```{r}
# Use pivot_longer() to make data longer format
starwars_select |>
  tidyr::pivot_longer(cols = c(hair_color, skin_color, eye_color), names_to = "attribute", values_to = "values", values_drop_na = TRUE) |>
  dplyr::arrange(name)

```

We can use the `pkg_lifecycle_statuses()` function from the {lifecycle} package to view function statuses in a specified package. Any function not "stable" will be listed. "Stability" harkens to the "[lifecycle](https://lifecycle.r-lib.org/articles/stages.html#superseded)" of a package or function.

```{r}
lifecycle::pkg_lifecycle_statuses("tidyr")
```

## Packages that help with installing/ attaching packages (yes, they exist)

Some books, like the [Epidemiologist R Handbook](https://epirhandbook.com/en/), recommend that you use the {pacman} package to install and load packages. This package has some extra utility that may be helpful. Other packages include {pak}, which have functions for installing packages from GitHub or other sources. There are other ways to install packages but beyond the scope of this document. See: [The Comprehensive Guide to Installing R Packages from CRAN, Bioconductor, GitHub and Co.](The%20Comprehensive%20Guide%20to%20Installing%20R%20Packages%20from%20CRAN,%20Bioconductor,%20GitHub%20and%20Co.)

# Cheatsheets

Cheatsheets are a good way of becoming familiar with package functions! Many of the most popular packages have cheatsheets as well. Access them here: [Posit Cheatsheets](https://rstudio.github.io/cheatsheets/)

![](images/clipboard-1345827158.png)

# Additional reading

I highly recommend visiting this page for more reading: [R Basics – The Epidemiologist R Handbook](https://epirhandbook.com/en/new_pages/basics.html#packages)
